// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package aqcommon.actions;

import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.IMendixObjectMember;
import com.mendix.systemwideinterfaces.core.meta.IMetaPrimitive;

/**
 * Automatically maps objects attribute values if the same attribute names are found. 
 * 
 * Users are able to enter custom mapping by creating a list of CustomMapHelper objects (Found AqCommon domain model) and passing that through the java action.
 * 
 * Following checks are made in the action:
 * - The attribute name matches
 * - The attribute type matches
 * - The type is supported
 * - [String attributes] The source length is less than or equal to the target length
 * - [Enum attributes] The type of the enum matches.
 * 
 * Supported types:
 * - String
 * - Boolean
 * - Date and Time
 * - Decimal
 * - Enum,
 * - Hashed String
 * - Integer
 * - Long
 * 
 * 
 * Currently if a source object attribute name is not found it is skipped. 
 * 
 * LogWarnings can be turned on which contains the following :
 * 
 * TYPE_MISMATCH - The target type does not match the source type
 * UNSUPPORTED_TYPE - The target type is not supported
 * LENGTH_MISMATCH - The source attribute has a longer length than the target (strings only)
 * ENUM_MISMATCH - The target enum does not match the source enum
 * 
 */
public class AutoMapper extends CustomJavaAction<java.lang.Boolean>
{
	private final java.lang.Boolean LogWarnings;
	private final IMendixObject SourceObject;
	private final IMendixObject TargetObject;
	/** @deprecated use com.mendix.utils.ListUtils.map(CustomMapping, com.mendix.systemwideinterfaces.core.IEntityProxy::getMendixObject) instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final java.util.List<IMendixObject> __CustomMapping;
	private final java.util.List<aqcommon.proxies.CustomMapHelper> CustomMapping;

	public AutoMapper(
		IContext context,
		java.lang.Boolean _logWarnings,
		IMendixObject _sourceObject,
		IMendixObject _targetObject,
		java.util.List<IMendixObject> _customMapping
	)
	{
		super(context);
		this.LogWarnings = _logWarnings;
		this.SourceObject = _sourceObject;
		this.TargetObject = _targetObject;
		this.__CustomMapping = _customMapping;
		this.CustomMapping = java.util.Optional.ofNullable(_customMapping)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(customMappingElement -> aqcommon.proxies.CustomMapHelper.initialize(getContext(), customMappingElement))
			.collect(java.util.stream.Collectors.toList());
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE

		Map<String, String> customAttributeMapping = CustomMapping.stream().collect(Collectors.toMap(e -> e.getSourceObjectAttributeName(), e -> e.getTargetObjectAttributeName()));
		

		if( TargetObject == null || SourceObject == null ){
			
			Core.getLogger(LOG_NODE_NAME).error("Unable to map; either the TargetObject or SourceObject is empty.");
			
			return false;
		}
		
		Set<String> targetMemberNames = TargetObject.getMembers(getContext()).keySet();


		for(String memberName : targetMemberNames){
			IMendixObjectMember<?> sourceMember;

			if(customAttributeMapping.containsValue(memberName)) {
				sourceMember = SourceObject.getMember(getContext(), getKeyByValue(customAttributeMapping, memberName));
			}
			else {
				sourceMember = SourceObject.getMember(getContext(), memberName);
			}
			
		
			// only map if we have got a matching member in the source object
			
			if( sourceMember != null ){					
				
				IMendixObjectMember<?> targetMember = TargetObject.getMember(getContext(), memberName);

				if( targetMember.getClass() != sourceMember.getClass()){
					logWarning(String.format("TYPE_MISMATCH: Attribute '%1s'; The target type '%2s' does not match the source type '%3s'",
							memberName, targetMember.getClass().getSimpleName(), sourceMember.getClass().getSimpleName()));
					continue;
				} 
				
				if( !isSupportedType(targetMember)){
					logWarning(String.format("UNSUPPORTED_TYPE: Attribute '%1s'; The target type '%1s' is not supported.",
							memberName, targetMember.getClass().getSimpleName()));
					
					continue;
				}
				
				// extra check on strings
				if(targetMember.getClass().getSimpleName().equals("MendixStringImpl")){
					IMetaPrimitive sourceStringMeta = Core.getMetaPrimitive(SourceObject.getMetaObject().getName() + "." + sourceMember.getName());
					IMetaPrimitive targetStringMeta = Core.getMetaPrimitive(TargetObject.getMetaObject().getName() + "." + targetMember.getName());


					if( sourceStringMeta.getLength() > targetStringMeta.getLength()){
						logWarning(String.format("LENGTH_MISMATCH: Attribute '%1s'; The source attribute has a longer length (%2$d) than the target (%3$d).",
								memberName, sourceStringMeta.getLength(), targetStringMeta.getLength()));
						continue;
					}
				}
				
				// extra check on enum
				if(targetMember.getClass().getSimpleName().equals("MendixEnumImpl")){
					IMetaPrimitive sourceEnumMeta = Core.getMetaPrimitive(SourceObject.getMetaObject().getName() + "." + sourceMember.getName());
					IMetaPrimitive targetEnumMeta = Core.getMetaPrimitive(TargetObject.getMetaObject().getName() + "." + targetMember.getName());

					
					if( !sourceEnumMeta.getEnumeration().getName().equals(targetEnumMeta.getEnumeration().getName())){
						logWarning(String.format("ENUM_MISMATCH: Attribute '%1s'; The target enum '%2s' does not match the source enum '%3s'",
								memberName, targetEnumMeta.getEnumeration().getName(), sourceEnumMeta.getEnumeration().getName()));
						continue;
					}				
				}
				
				TargetObject.setValue(getContext(), memberName, SourceObject.getValue(getContext(), sourceMember.getName()));				
			}
		}	
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "AutoMapper";
	}

	// BEGIN EXTRA CODE
	private static final String LOG_NODE_NAME = "AutoMapper";
	
	private Boolean isSupportedType(IMendixObjectMember<?> member){
		List<String> supportedTypes = Arrays.asList("MendixStringImpl", "MendixBooleanImpl", "MendixDateTimeImpl", "MendixDecimalImpl", "MendixEnumImpl", "MendixHashStringImpl", "MendixIntegerImpl", "MendixLongImpl");
		
		String simpleName = member.getClass().getSimpleName();
		
		return supportedTypes.contains(simpleName);
	}
	
	private void logWarning(String message){
		if(this.LogWarnings){
			Core.getLogger(LOG_NODE_NAME).warn(message);
		}
	}
	
	public static <T, E> T getKeyByValue(Map<T, E> map, E value) {
	    for (Entry<T, E> entry : map.entrySet()) {
	        if (Objects.equals(value, entry.getValue())) {
	            return entry.getKey();
	        }
	    }
	    return null;
	}
	// END EXTRA CODE
}
