// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package aqcommon.actions;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.IMendixObjectMember;

/**
 * Compares two given object if they are the same or not by checking the values of the attributes.
 * 
 * If Strick Checking is turned on it only checks for attributes and association if the type of the object is the same.
 * 
 * Checking for association looks checks if the ID`s of the associations are the same. 
 * 
 * Users are able to enter a string of attributes they don`t want to compare. This should be separated by a coma and use a AqCommon delimiter to seperate them to a StringItem list.
 * 
 */
public class CompareObjects extends CustomJavaAction<java.lang.Boolean>
{
	private final IMendixObject MainObject;
	private final IMendixObject ObjectToCompare;
	private final java.lang.Boolean CheckForAssociation;
	/** @deprecated use com.mendix.utils.ListUtils.map(AttributesToSkip, com.mendix.systemwideinterfaces.core.IEntityProxy::getMendixObject) instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final java.util.List<IMendixObject> __AttributesToSkip;
	private final java.util.List<aqcommon.proxies.StringItem> AttributesToSkip;
	private final java.lang.Boolean StrickChecking;

	public CompareObjects(
		IContext context,
		IMendixObject _mainObject,
		IMendixObject _objectToCompare,
		java.lang.Boolean _checkForAssociation,
		java.util.List<IMendixObject> _attributesToSkip,
		java.lang.Boolean _strickChecking
	)
	{
		super(context);
		this.MainObject = _mainObject;
		this.ObjectToCompare = _objectToCompare;
		this.CheckForAssociation = _checkForAssociation;
		this.__AttributesToSkip = _attributesToSkip;
		this.AttributesToSkip = java.util.Optional.ofNullable(_attributesToSkip)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(attributesToSkipElement -> aqcommon.proxies.StringItem.initialize(getContext(), attributesToSkipElement))
			.collect(java.util.stream.Collectors.toList());
		this.StrickChecking = _strickChecking;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
		if(StrickChecking) {
			if(MainObject.getType() != ObjectToCompare.getType()) {
				return false;
			}
		}

		if (MainObject.getId() == ObjectToCompare.getId()) {
			return true;
		} 
		
		else {
			return compareLists();
		}
		
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CompareObjects";
	}

	// BEGIN EXTRA CODE
	
	
	//Looping the objects. If we want to check if the objects have the same association we are using HashMaps otherwise just a list with primitives values.
	//For attributes to skip we have a helper function for the default ones such as createdBy,changedBy...etc and use a stream to check for the user input ones. 
	
	private ArrayList<String> checkMember (IMendixObject object) {
		IContext ctx = this.getContext();
		ArrayList<String> arrayToReturn = new ArrayList<>();
		
		if(CheckForAssociation) {
			Map<String, ? extends IMendixObjectMember<?>> member = object.getMembers(ctx);
			for (var entry : member.entrySet()) {
				if (!skipDefaultMembers(entry.getKey()) && !AttributesToSkip.stream().anyMatch(e -> e.getValue().equals(entry.getKey()))) {
					arrayToReturn.add(String.valueOf(entry.getValue().getValue(ctx)));
				}
			}
		}
		
		else {
			List<? extends IMendixObjectMember<?>> memberList = object.getPrimitives(ctx);
			for(var listmember : memberList) {
				if (!skipDefaultMembers(listmember.getName()) && !AttributesToSkip.stream().anyMatch(e -> e.getValue().equals(listmember.getName()))) {
					arrayToReturn.add(String.valueOf(listmember.getValue(ctx)));
				}
				
			}		
		}
		
		return arrayToReturn;
	}
		
	private boolean compareLists() {

		ArrayList<String> mainMember = checkMember(MainObject);
		ArrayList<String> memberToCheck = checkMember(ObjectToCompare);
		Collections.sort(mainMember);
		Collections.sort(memberToCheck);

		return mainMember.equals(memberToCheck) ? true : false;
	}

	
	//This works fine, but realised there are has... functions built in so can change to that if needed.
	private boolean skipDefaultMembers(String str) {
		boolean skipMember = false;

		
		if(str == "createdDate") {
			skipMember = true;
		}
		else if (str == "System.owner") {
			skipMember = true;
		}
		else if (str == "System.changedBy") {
			skipMember = true;
		}
		else if (str == "changedDate") {
			skipMember = true;
		}


		return skipMember;
	}
	// END EXTRA CODE
}
